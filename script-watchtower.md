---
title: Script de maintenance Proxmox : mise √† jour de Watchtower
description: Ce script Bash est con√ßu pour les administrateurs utilisant Proxmox Virtual Environment (VE) pour h√©berger des conteneurs LXC ex√©cutant Docker.
published: true
date: 2025-10-27T22:02:13.288Z
tags: docker, lxc, script, bash, watchtower
editor: markdown
dateCreated: 2025-10-26T16:28:46.835Z
---

# üöÄ Script de Maintenance Proxmox : Mise √† Jour de Watchtower

Ce guide fournit des scripts Bash robustes pour les utilisateurs de Proxmox VE. Ils automatisent la modification des fichiers `docker-compose.yml` afin d'ajuster la planification de l'outil de mise √† jour automatique des images Docker, **Watchtower**.

## 1\. Informations G√©n√©rales

### 1.1. üéØ √Ä Quoi Sert Ce Script ?

| Champ | Description |
| :--- | :--- |
| **Objectif Principal** | Remplacer l'intervalle de mise √† jour de Watchtower (p. ex., toutes les 3 heures) par une **planification CRON sp√©cifique** (p. ex., tous les mercredis √† 10h00). |
| **Pour Qui ?** | Les utilisateurs de Proxmox qui g√®rent des LXC avec des services Docker (`docker-compose`) et qui veulent **√©viter les mises √† jour al√©atoires** qui pourraient perturber les services en production. |
| **Avantages Techniques** | Le script g√®re les subtilit√©s de l'environnement Proxmox : il filtre uniquement les conteneurs actifs et utilise des m√©thodes non bloquantes pour √©viter les arr√™ts sur les conteneurs mal configur√©s. |

-----

## 2\. üíª Script 1 : Conversion d'Intervalle vers CRON (Premi√®re Utilisation)

Ce script est destin√© √† √™tre ex√©cut√© une seule fois pour remplacer l'ancienne variable d'intervalle (`WATCHTOWER_POLL_INTERVAL`) par la nouvelle variable de planification CRON (`WATCHTOWER_SCHEDULE`).

### 2.1. Installation et Pr√©paration

Le script doit √™tre ex√©cut√© en tant qu'utilisateur **root** sur votre n≈ìud h√¥te Proxmox VE.

1.  Connectez-vous √† votre n≈ìud Proxmox en SSH.
2.  Cr√©ez le fichier du script (par exemple, `script1_watchtower.sh`) :
    ```bash
    nano /root/script1_watchtower.sh
    ```
3.  Collez le code du **Script 1** ci-dessous.
4.  Rendez le script ex√©cutable :
    ```bash
    chmod +x /root/script1_watchtower.sh
    ```

### 2.2. Le Script 1 (Version Initiale)

```bash
#!/bin/bash

# Configuration
# ==============
# Remplacement: WATCHTOWER_POLL_INTERVAL=10800 sera remplac√© par WATCHTOWER_SCHEDULE=0 0 10 ? * WED (Mercredi 10h00)
MODIFICATION_SED='s/- WATCHTOWER_POLL_INTERVAL=10800/- WATCHTOWER_SCHEDULE=0 0 10 ? * WED/'
TARGET_CONTAINER_PATH_TO_TEST="/root/watchtower/docker-compose.yml" # Emplacement du fichier Watchtower √† l'int√©rieur du conteneur


# Fonction pour red√©marrer Docker Compose
restart_docker_compose() {
    local CTID=$1
    local COMPOSE_DIR="/root/watchtower"
    local TIMEOUT_DURATION=30

    echo "   Tentative de red√©marrage avec 'docker compose' dans $COMPOSE_DIR (Timeout: ${TIMEOUT_DURATION}s)..."

    local LOG_FILE="/tmp/pct_exec_log_$CTID.log"
    timeout "$TIMEOUT_DURATION" pct exec "$CTID" -- sh -c "cd $COMPOSE_DIR && docker compose down && docker compose up -d" > "$LOG_FILE" 2>&1
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        grep -E 'Removed|Created|Started' "$LOG_FILE"
        echo "   ‚úÖ Red√©marrage r√©ussi avec 'docker compose'."
        rm -f "$LOG_FILE"
        return 0
    elif [ $exit_code -eq 124 ]; then
        echo "   ‚ö†Ô∏è Red√©marrage forc√© par timeout. Service probablement relanc√©. Continuer."
        rm -f "$LOG_FILE"
        return 0
    else
        echo "   ‚ùå √âchec du red√©marrage (Code: $exit_code). Consultez le fichier $LOG_FILE pour les d√©tails."
        return 1
    fi
}


# 1. Identification des conteneurs LXC √† traiter
echo "Recherche des conteneurs LXC ACTIFS dont le nom contient 'docker' (via pct)..."

CONTAINER_IDS=$(pct list | awk '/running/ && /docker/ {print $1}')


# Traitement des Conteneurs
# =========================
if [ -z "$CONTAINER_IDS" ]; then
    echo "‚ö†Ô∏è Aucun conteneur LXC/CT en cours d'ex√©cution avec 'docker' dans son nom n'a √©t√© trouv√©. Aucune action n'a √©t√© effectu√©e."
    exit 0
fi

echo "Conteneurs trouv√©s (ID): $CONTAINER_IDS"
echo "-----------------------------------"

for CTID in $CONTAINER_IDS; do
    CONTAINER_NAME=$(pct config "$CTID" | grep 'hostname' | awk '{print $2}')
    echo "‚ñ∂Ô∏è Traitement du conteneur LXC (ID $CTID) : $CONTAINER_NAME"
    
    # 2. V√©rification de l'existence du fichier (m√©thode non bloquante : test -f)
    pct exec "$CTID" -- test -f "$TARGET_CONTAINER_PATH_TO_TEST" >/dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        echo "   Fichier de configuration Watchtower trouv√© √†: $TARGET_CONTAINER_PATH_TO_TEST"

        # 3. Modification du fichier (pct pull/push)
        TEMP_FILE="/tmp/docker-compose-temp-$CTID.yml"
        
        # Copie le fichier du CT vers l'h√¥te
        pct pull "$CTID" "$TARGET_CONTAINER_PATH_TO_TEST" "$TEMP_FILE" >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            echo "‚ùå ERREUR: Impossible de copier le fichier depuis le conteneur $CTID. Ignor√©."
            rm -f "$TEMP_FILE" 2>/dev/null
            continue
        fi

        TEMP_FILE_BAK="${TEMP_FILE}.bak"
        cp "$TEMP_FILE" "$TEMP_FILE_BAK"
        
        # Ex√©cute la substitution SED
        sed -i "$MODIFICATION_SED" "$TEMP_FILE"
        echo "   ‚úÖ Modification appliqu√©e au fichier temporaire."
        
        # Sauvegarde l'original dans le CT, puis pousse le fichier modifi√©
        pct exec "$CTID" -- cp "$TARGET_CONTAINER_PATH_TO_TEST" "$TARGET_CONTAINER_PATH_TO_TEST.bak" >/dev/null 2>&1
        pct push "$CTID" "$TEMP_FILE" "$TARGET_CONTAINER_PATH_TO_TEST" >/dev/null 2>&1
        echo "   ‚úÖ Fichier mis √† jour dans le conteneur. Sauvegarde interne: ${TARGET_CONTAINER_PATH_TO_TEST}.bak"
        
        rm -f "$TEMP_FILE" "$TEMP_FILE_BAK"
        
        # 4. Red√©marrage du service Docker Compose
        restart_docker_compose "$CTID"
        
        if [ $? -eq 0 ]; then
             echo "‚úÖ Op√©ration compl√®te termin√©e pour $CONTAINER_NAME (ID $CTID)."
        else
             echo "‚ö†Ô∏è Modification r√©ussie, mais red√©marrage √©chou√© pour $CONTAINER_NAME (ID $CTID). **Veuillez red√©marrer le service manuellement.**"
        fi
    else
        echo "   Fichier de configuration Watchtower non trouv√© √† $TARGET_CONTAINER_PATH_TO_TEST. Ce CT/LXC est ignor√©."
    fi
    
    echo "-----------------------------------"
done

echo "Toutes les op√©rations sont termin√©es."
```

### 2.3. Ex√©cuter le Script

Pour lancer le **Script 1** :

```bash
/root/script1_watchtower.sh
```

-----

## 3\. üîß Adaptation du Script pour d'Autres Usages

Le script est con√ßu pour √™tre facilement adaptable √† toute autre modification de fichier dans vos conteneurs LXC.

### 3.1. Adapter la Cible (O√π et Qui)

Pour modifier le comportement de ciblage et de recherche :

| Variable | Usage | Comment l'Adapter |
| :--- | :--- | :--- |
| **`CONTAINER_IDS`** | **Ciblage :** Liste les CT √† traiter. | Modifiez l'`awk` pour cibler des noms diff√©rents (p. ex., `/nginx/` au lieu de `/docker/`) ou retirez `/docker/` pour cibler tous les LXC actifs. |
| **`TARGET_CONTAINER_PATH_TO_TEST`** | **Chemin du Fichier :** Chemin exact du fichier *dans le conteneur*. | Modifiez-le pour pointer vers tout autre fichier de configuration (p. ex., `/etc/nginx/nginx.conf`). |
| **`COMPOSE_DIR`** | **R√©pertoire de Travail :** Utilis√© pour le `cd` avant le red√©marrage. | Si vous modifiez un fichier qui n√©cessite un red√©marrage avec `docker compose`, mettez ici le r√©pertoire contenant le `docker-compose.yml`. |

### 3.2. Adapter la Modification (Quoi)

La variable **`MODIFICATION_SED`** contient l'expression de substitution qui effectue la modification. Elle est au format `sed`: `'s/CHA√éNE_RECHERCH√âE/CHA√éNE_DE_REMPLACEMENT/'`.

| √âl√©ment | Description | Exemple d'Adaptation |
| :--- | :--- | :--- |
| **Recherche** (`CHA√éNE_RECHERCH√âE`) | La ligne exacte ou le motif √† trouver. | Pour changer un port `8080:8080`, utilisez : `8080:8080`. |
| **Remplacement** (`CHA√éNE_DE_REMPLACEMENT`) | La nouvelle valeur √† ins√©rer. | Pour changer le port en `8081:8080`, utilisez : `8081:8080`. |

**Exemple d'adaptation :** Si vous vouliez remplacer l'adresse d'un serveur dans un fichier de configuration :

```bash
# Remplacer 'http://old-server:8080' par 'http://new-server:9000'
MODIFICATION_SED='s/http:\/\/old-server:8080/http:\/\/new-server:9000/' 
```

### 3.3. Adapter l'Action Post-Modification

L'√©tape de red√©marrage est g√©r√©e par la fonction **`restart_docker_compose`**.

  * **Si vous modifiez un service Docker :** Laissez la fonction telle quelle.
  * **Si vous modifiez un service syst√®me (ex: Nginx) :** Modifiez le corps de la fonction pour utiliser `pct exec "$CTID" -- systemctl restart nginx` au lieu de `docker compose down/up`. Pensez √† ajuster le `TIMEOUT_DURATION` si n√©cessaire.

-----

## 4\. üõë Annexe : Substitution Robuste (Script 2)

Le **Script 1** est tr√®s efficace pour la premi√®re conversion. Cependant, il peut √©chouer si vous tentez de **modifier √† nouveau** la planification CRON, car l'outil `sed` est sensible aux probl√®mes de correspondance de cha√Æne exacte apr√®s la premi√®re modification.

Pour garantir que vos changements de planification (ex: passer de Mercredi √† Vendredi) fonctionnent **√† chaque fois**, utilisez le **Script 2**.

### ‚ö†Ô∏è Avertissement

Utilisez le **Script 2** uniquement si vous avez d√©j√† ex√©cut√© le Script 1 et que la variable `WATCHTOWER_SCHEDULE` est d√©j√† pr√©sente dans vos fichiers `docker-compose.yml`.

### 4.1. üöÄ Script 2 : Modification d'une planification existante

Ce script utilise une expression r√©guli√®re pour cibler le nom de la variable (`- WATCHTOWER_SCHEDULE=`) et remplacer ensuite l'int√©gralit√© de sa valeur.

```bash
#!/bin/bash

# Configuration
# ==============
# La substitution robuste: recherche la ligne commen√ßant par WATCHTOWER_SCHEDULE= et remplace TOUTE la valeur.
# Remplacement: [WATCHTOWER_SCHEDULE=...] sera remplac√© par WATCHTOWER_SCHEDULE=0 0 10 ? * FRI (Vendredi 10h00)
MODIFICATION_SED='s/^- WATCHTOWER_SCHEDULE=.*/- WATCHTOWER_SCHEDULE=0 0 10 ? * FRI/'
TARGET_CONTAINER_PATH_TO_TEST="/root/watchtower/docker-compose.yml" 


# Fonction pour red√©marrer Docker Compose (identique au Script 1)
restart_docker_compose() {
    local CTID=$1
    local COMPOSE_DIR="/root/watchtower"
    local TIMEOUT_DURATION=30

    echo "   Tentative de red√©marrage avec 'docker compose' dans $COMPOSE_DIR (Timeout: ${TIMEOUT_DURATION}s)..."

    local LOG_FILE="/tmp/pct_exec_log_$CTID.log"
    timeout "$TIMEOUT_DURATION" pct exec "$CTID" -- sh -c "cd $COMPOSE_DIR && docker compose down && docker compose up -d" > "$LOG_FILE" 2>&1
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        grep -E 'Removed|Created|Started' "$LOG_FILE"
        echo "   ‚úÖ Red√©marrage r√©ussi avec 'docker compose'."
        rm -f "$LOG_FILE"
        return 0
    elif [ $exit_code -eq 124 ]; then
        echo "   ‚ö†Ô∏è Red√©marrage forc√© par timeout. Service probablement relanc√©. Continuer."
        rm -f "$LOG_FILE"
        return 0
    else
        echo "   ‚ùå √âchec du red√©marrage (Code: $exit_code). Consultez le fichier $LOG_FILE pour les d√©tails."
        return 1
    fi
}


# 1. Identification des conteneurs LXC √† traiter (identique au Script 1)
echo "Recherche des conteneurs LXC ACTIFS dont le nom contient 'docker' (via pct)..."
CONTAINER_IDS=$(pct list | awk '/running/ && /docker/ {print $1}')


# Traitement des Conteneurs (identique au Script 1)
# =========================
if [ -z "$CONTAINER_IDS" ]; then
    echo "‚ö†Ô∏è Aucun conteneur LXC/CT en cours d'ex√©cution avec 'docker' dans son nom n'a √©t√© trouv√©. Aucune action n'a √©t√© effectu√©e."
    exit 0
fi

echo "Conteneurs trouv√©s (ID): $CONTAINER_IDS"
echo "-----------------------------------"

for CTID in $CONTAINER_IDS; do
    CONTAINER_NAME=$(pct config "$CTID" | grep 'hostname' | awk '{print $2}')
    echo "‚ñ∂Ô∏è Traitement du conteneur LXC (ID $CTID) : $CONTAINER_NAME"
    
    # 2. V√©rification de l'existence du fichier
    pct exec "$CTID" -- test -f "$TARGET_CONTAINER_PATH_TO_TEST" >/dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        echo "   Fichier de configuration Watchtower trouv√© √†: $TARGET_CONTAINER_PATH_TO_TEST"

        # 3. Modification du fichier
        TEMP_FILE="/tmp/docker-compose-temp-$CTID.yml"
        
        pct pull "$CTID" "$TARGET_CONTAINER_PATH_TO_TEST" "$TEMP_FILE" >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            echo "‚ùå ERREUR: Impossible de copier le fichier depuis le conteneur $CTID. Ignor√©."
            rm -f "$TEMP_FILE" 2>/dev/null
            continue
        fi

        TEMP_FILE_BAK="${TEMP_FILE}.bak"
        cp "$TEMP_FILE" "$TEMP_FILE_BAK"
        
        # Application de la substitution robuste
        sed -i "$MODIFICATION_SED" "$TEMP_FILE"
        echo "   ‚úÖ Modification appliqu√©e au fichier temporaire."
        
        pct exec "$CTID" -- cp "$TARGET_CONTAINER_PATH_TO_TEST" "$TARGET_CONTAINER_PATH_TO_TEST.bak" >/dev/null 2>&1
        pct push "$CTID" "$TEMP_FILE" "$TARGET_CONTAINER_PATH_TO_TEST" >/dev/null 2>&1
        echo "   ‚úÖ Fichier mis √† jour dans le conteneur. Sauvegarde interne: ${TARGET_CONTAINER_PATH_TO_TEST}.bak"
        
        rm -f "$TEMP_FILE" "$TEMP_FILE_BAK"
        
        # 4. Red√©marrage du service Docker Compose
        restart_docker_compose "$CTID"
        
        if [ $? -eq 0 ]; then
             echo "‚úÖ Op√©ration compl√®te termin√©e pour $CONTAINER_NAME (ID $CTID)."
        else
             echo "‚ö†Ô∏è Modification r√©ussie, mais red√©marrage √©chou√© pour $CONTAINER_NAME (ID $CTID). **Veuillez red√©marrer le service manuellement.**"
        fi
    else
        echo "   Fichier de configuration Watchtower non trouv√© √† $TARGET_CONTAINER_PATH_TO_TEST. Ce CT/LXC est ignor√©."
    fi
    
    echo "-----------------------------------"
done

echo "Toutes les op√©rations sont termin√©es."
```